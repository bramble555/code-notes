# Top Interview 150
- 前四道考察双指针
- 169.majorityElement 哈希(不是最优)  摩尔投票算法
- 189.Rotate Array 常规做法会超时，反转全部，反转前 k 个元素， 再反转 后面元素 
- 121.maxProfit  解法一 暴力 解法二 使用动态规划,每一次计算 当天的最大利润(记录之前最小的购买价格)
- 122.maxProfit 解法一 贪心(每次计算当前与前一天的之前，也就是利润，如果利润大于0，记录下来，很巧妙)
- 55.从后面往前贪
- 45.标记每次跳的步数，根据前面的步数+1
- 274.hIndex 注意读题
- 380.RandomizedSet 哈希 map
- 238.productExceptSelf  product:乘积 解法: 利用前缀和思想，前缀积，后缀积，找规律
- 134.canCompleteCircuit curSum前缀和，计算当前curSum, 如果小于0，那么起始点就是下一个下标
- 135.candy 从两个方向遍历数组，找单增区间和单减区间
- 42.跳过 to do
- 13.暴力。GPT 优化代码，前面小的-，大的+
- 
- 14.暴力。查找最大公共字符串前缀，那么都公共前缀了，我第0个前缀也是前缀，不非要比较长度最小字符串的前缀
- 6.找规律。然后想办法求出 1，2，3，2，1，2，...，然后再想办法根据 flag 输出 res
- 28.kmp 目前不会，暴力。注意特殊情况
- 125.先转成数字和小写字母，最好不要用 strings 包
- 392.暴力。（优化双指针）
- 318.预处理把每一个 word 生成一个子码(| 运算),然后 & == 0 是俩个 word 每个字母都不同，优化 用一个 map 只存储 len 长的，再优化，结构体排序
- 11.最大面积。双指针
- 167.有序数组俩数之和。双指针
- 15.关键在于去重
- 209.虽小子数组长度大于 target,滑动窗口
- 3.滑动窗口 map
- 
- 76.
- 36.关键在于找出 9 个小矩阵，那么就查找9个小矩阵的左上角元素！
- 54.四个指针，遍历完上右下左分别判断边界情况
- 289.标记法。活变死 死变活 用不同的标记。
- 383.查看大字符串是否包含了小字符串
- 205.是否为对应关系(abab 对应 bcbc),那就用 map 一一映射关系，如果 key 存在，那就判断 value 是为否对应的，如果不存在，那就添加。key 如果不存在，value 如果存在，那就 false 咯
- 242.类比205，但不过把字母换成了单词
- 49.查看是否在一个组，先对字符串排序。不能用位运算，重复多了直接超过了
- 1.map查找更快
- 202.如果重复出现，说明循环了。那就用 map 查询是否出现过；第二种方法是 有限次数查询是否满足快乐
- 219.保存上次数字上次出现过的位置
- 128.set 存放，然后如果没有前一个元素，置为1，并且一直向后查找。如果有前一个元素，那就 continue。关键点在于查找每个组中第一个元素。
- 56.关键在于有重复，那区间没有重复的时候再加入结果
- 57.关键再去分情况。三种情况，一种 intervals[i][1] < new[0] 也就是当前 i 比 new 小，res 加入 intervals[i], 另外一种情况 intervals[i][0] > new[1],res 加入 new,第三种情况 有重叠，重叠了那就 更新 new；这些做完之后，还要加入最后一次的 new
- 452.射击气球。tempEnd 表示上一次结束的位置。tempEnd 尽量大，那就根据第二个元素进行排序了。
- 150.逆波兰表达式求值。理解其过程就很好写了。遇到操作符取出俩个数字。然后将结果入
- 71.入栈，出栈注意 + 的 res 位置。为什么不能用队列？当 传入的是 ..  ，你怎么获取你最后一个元素，？？，并把它移除？那只能构造一个双向队列了。
- 155.维护栈中最小元素，构造另外一个栈
- 141.判断链表是否有环，那就快慢指针，看是否相遇
- 2.逐位相加,大于等于10的向后+1(不用反转)
- 3.有一个random,random可能你创建的时候还未生成那个 Node,所以 要用 map 存储建议新旧结点的映射关系.然后第二次遍历再添加 random
- 92.map 存储反转
- 25.每次反转 K 组,先计算反转几次,然后 每次 k 组反转
- 82.删除所有重复过的结点. 双指针嘛,然后之前是添加不重复的元素,那就 fast 指针 多 + 1
- 61.rotate LinkList .这个相较于数组来说, LinkList 可以循环.可以先把链表循环,然后找到尾结点,然后 指向空就好了
- 86.partition LinkList. 把小于等于 val 的 结点 存入一个 list,然后大于 val 的结点存入另外一个 list ,然后指向.为什么不能俩次遍历原本的 LinkList 呢? to do
- 104.求二叉树的最大深度,那就和求最大高度一样的 后序遍历 左右中,向上返回
- 100.判断俩个树是否一样,那就判断 q 和 p 的 左右孩子是否都一样, 值是否一样
- 226.反转树,就是把原来的树变成对称树.后序遍历,也可以先序遍历,每次交换左右孩子
- 101.判断是否能对称树.那就看最外边结点是否相等,最里面结点是否相等
- 102.层序遍历.