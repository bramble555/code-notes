# Top Interview 150
- 前四道考察双指针
- 169.majorityElement 哈希(不是最优)  摩尔投票算法
- 189.Rotate Array 常规做法会超时，反转全部，反转前 k 个元素， 再反转 后面元素 
- 121.maxProfit  解法一 暴力 解法二 使用动态规划,每一次计算 当天的最大利润(记录之前最小的购买价格)
- 122.maxProfit 解法一 贪心(每次计算当前与前一天的之前，也就是利润，如果利润大于0，记录下来，很巧妙)
- 55.从后面往前贪
- 45.标记每次跳的步数，根据前面的步数+1
- 274.hIndex 注意读题
- 380.RandomizedSet 哈希 map
- 238.productExceptSelf  product:乘积 解法: 利用前缀和思想，前缀积，后缀积，找规律
- 134.canCompleteCircuit curSum前缀和，计算当前curSum, 如果小于0，那么起始点就是下一个下标
- 135.candy 从两个方向遍历数组，找单增区间和单减区间
- 42.跳过 to do
- 13.暴力。GPT 优化代码，前面小的-，大的+
- 
- 14.暴力。查找最大公共字符串前缀，那么都公共前缀了，我第0个前缀也是前缀，不非要比较长度最小字符串的前缀
- 6.找规律。然后想办法求出 1，2，3，2，1，2，...，然后再想办法根据 flag 输出 res
- 28.kmp 目前不会，暴力。注意特殊情况
- 125.先转成数字和小写字母，最好不要用 strings 包
- 392.暴力。（优化双指针）
- 318.预处理把每一个 word 生成一个子码(| 运算),然后 & == 0 是俩个 word 每个字母都不同，优化 用一个 map 只存储 len 长的，再优化，结构体排序
- 11.最大面积。双指针
- 167.有序数组俩数之和。双指针
- 15.关键在于去重
- 209.虽小子数组长度大于 target,滑动窗口
- 3.滑动窗口 map
- 
- 76.
- 36.关键在于找出 9 个小矩阵，那么就查找9个小矩阵的左上角元素！
- 54.四个指针，遍历完上右下左分别判断边界情况
- 289.标记法。活变死 死变活 用不同的标记。
- 383.查看大字符串是否包含了小字符串
- 205.是否为对应关系(abab 对应 bcbc),那就用 map 一一映射关系，如果 key 存在，那就判断 value 是为否对应的，如果不存在，那就添加。key 如果不存在，value 如果存在，那就 false 咯
- 242.类比205，但不过把字母换成了单词
- 49.查看是否在一个组，先对字符串排序。不能用位运算，重复多了直接超过了
- 1.map查找更快
- 202.如果重复出现，说明循环了。那就用 map 查询是否出现过；第二种方法是 有限次数查询是否满足快乐
- 219.保存上次数字上次出现过的位置
- 128.set 存放，然后如果没有前一个元素，置为1，并且一直向后查找。如果有前一个元素，那就 continue。关键点在于查找每个组中第一个元素。
- 56.关键在于有重复，那区间没有重复的时候再加入结果
- 57.关键再去分情况。三种情况，一种 intervals[i][1] < new[0] 也就是当前 i 比 new 小，res 加入 intervals[i], 另外一种情况 intervals[i][0] > new[1],res 加入 new,第三种情况 有重叠，重叠了那就 更新 new；这些做完之后，还要加入最后一次的 new
- 452.射击气球。tempEnd 表示上一次结束的位置。tempEnd 尽量大，那就根据第二个元素进行排序了。
- 150.逆波兰表达式求值。理解其过程就很好写了。遇到操作符取出俩个数字。然后将结果入
- 71.入栈，出栈注意 + 的 res 位置。为什么不能用队列？当 传入的是 ..  ，你怎么获取你最后一个元素，？？，并把它移除？那只能构造一个双向队列了。
- 155.维护栈中最小元素，构造另外一个栈
- 141.判断链表是否有环，那就快慢指针，看是否相遇